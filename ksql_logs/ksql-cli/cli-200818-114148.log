[2020-08-18 11:41:50,403] WARN Writing to metrics Kafka topic will be disabled (io.confluent.support.metrics.PhoneHomeConfig:61)
[2020-08-18 11:41:50,407] WARN Enforcing customer ID 'anonymous' (io.confluent.support.metrics.PhoneHomeConfig:66)
[2020-08-18 11:41:50,431] WARN Please note that the version check feature of KSQL is enabled.  With this enabled, this instance is configured to collect and report anonymously the version information to Confluent, Inc. ("Confluent") or its parent, subsidiaries, affiliates or service providers every 24hours.  This Metadata may be transferred to any country in which Confluent maintains facilities.  For a more in depth discussion of how Confluent processes such information, please read our Privacy Policy located at http://www.confluent.io/privacy. By proceeding with `confluent.support.metrics.enable=true`, you agree to all such collection, transfer and use of Version information by Confluent. You can turn the version check  feature off by setting `confluent.support.metrics.enable=false` in the KSQL configuration and restarting the KSQL.  See the Confluent Platform documentation for further information. (io.confluent.ksql.version.metrics.KsqlVersionCheckerAgent:90)
[2020-08-18 11:42:33,092] ERROR  (io.confluent.ksql.cli.Cli:177)
io.confluent.ksql.parser.exception.ParseFailedException: line 1:6: no viable alternative at input 'SHOW |'
Statement: SHOW | LIST TABLES;
	at io.confluent.ksql.parser.DefaultKsqlParser.parse(DefaultKsqlParser.java:64)
	at io.confluent.ksql.cli.Cli.handleStatements(Cli.java:265)
	at io.confluent.ksql.cli.Cli.handleLine(Cli.java:232)
	at io.confluent.ksql.cli.Cli.runInteractively(Cli.java:171)
	at io.confluent.ksql.Ksql.run(Ksql.java:115)
	at io.confluent.ksql.Ksql.main(Ksql.java:74)
Caused by: io.confluent.ksql.parser.ParsingException: line 1:6: no viable alternative at input 'SHOW |'
	at io.confluent.ksql.parser.DefaultKsqlParser$1.syntaxError(DefaultKsqlParser.java:50)
	at org.antlr.v4.runtime.ProxyErrorListener.syntaxError(ProxyErrorListener.java:41)
	at org.antlr.v4.runtime.Parser.notifyErrorListeners(Parser.java:544)
	at org.antlr.v4.runtime.DefaultErrorStrategy.reportNoViableAlternative(DefaultErrorStrategy.java:282)
	at org.antlr.v4.runtime.DefaultErrorStrategy.reportError(DefaultErrorStrategy.java:121)
	at io.confluent.ksql.parser.SqlBaseParser.statement(SqlBaseParser.java:1779)
	at io.confluent.ksql.parser.SqlBaseParser.singleStatement(SqlBaseParser.java:264)
	at io.confluent.ksql.parser.SqlBaseParser.statements(SqlBaseParser.java:212)
	at io.confluent.ksql.parser.DefaultKsqlParser.getParseTree(DefaultKsqlParser.java:108)
	at io.confluent.ksql.parser.DefaultKsqlParser.parse(DefaultKsqlParser.java:57)
	... 5 more
Caused by: org.antlr.v4.runtime.NoViableAltException
	at org.antlr.v4.runtime.atn.ParserATNSimulator.noViableAlt(ParserATNSimulator.java:2023)
	at org.antlr.v4.runtime.atn.ParserATNSimulator.execATN(ParserATNSimulator.java:467)
	at org.antlr.v4.runtime.atn.ParserATNSimulator.adaptivePredict(ParserATNSimulator.java:393)
	at io.confluent.ksql.parser.SqlBaseParser.statement(SqlBaseParser.java:1017)
	... 9 more
[2020-08-18 11:43:23,480] ERROR Exception while preparing statement: CIQ000000017_OUT_CHARGE_COMPACTED does not exist.
Statement: SELECT * FROM CIQ000000017_out_charge_compacted;
Caused by: CIQ000000017_OUT_CHARGE_COMPACTED does not exist.
io.confluent.ksql.engine.EngineContext.prepare(EngineContext.java:154)
io.confluent.ksql.engine.KsqlEngine.prepare(KsqlEngine.java:170)
io.confluent.ksql.rest.server.StatementParser.parseSingleStatement(StatementParser.java:42)
io.confluent.ksql.rest.server.resources.streaming.StreamedQueryResource.parseStatement(StreamedQueryResource.java:177)
io.confluent.ksql.rest.server.resources.streaming.StreamedQueryResource.streamQuery(StreamedQueryResource.java:156)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
org.glassfish.jersey.server.model.internal.ResourceMethodInvocationHandlerFactory.lambda$static$0(ResourceMethodInvocationHandlerFactory.java:52)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher$1.run(AbstractJavaResourceMethodDispatcher.java:124)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.invoke(AbstractJavaResourceMethodDispatcher.java:167)
org.glassfish.jersey.server.model.internal.JavaResourceMethodDispatcherProvider$ResponseOutInvoker.doDispatch(JavaResourceMethodDispatcherProvider.java:176)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.dispatch(AbstractJavaResourceMethodDispatcher.java:79)
org.glassfish.jersey.server.model.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:469)
org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:391)
org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:80)
org.glassfish.jersey.server.ServerRuntime$1.run(ServerRuntime.java:253)
org.glassfish.jersey.internal.Errors$1.call(Errors.java:248)
org.glassfish.jersey.internal.Errors$1.call(Errors.java:244)
org.glassfish.jersey.internal.Errors.process(Errors.java:292)
org.glassfish.jersey.internal.Errors.process(Errors.java:274)
org.glassfish.jersey.internal.Errors.process(Errors.java:244)
org.glassfish.jersey.process.internal.RequestScope.runInScope(RequestScope.java:265)
org.glassfish.jersey.server.ServerRuntime.process(ServerRuntime.java:232)
org.glassfish.jersey.server.ApplicationHandler.handle(ApplicationHandler.java:680)
org.glassfish.jersey.servlet.WebComponent.serviceImpl(WebComponent.java:394)
org.glassfish.jersey.servlet.ServletContainer.serviceImpl(ServletContainer.java:386)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:561)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:502)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:439)
org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1604)
org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:545)
org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)
org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1607)
org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)
org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1297)
org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:188)
org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:485)
org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1577)
org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:186)
org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1212)
org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146)
org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146)
org.eclipse.jetty.server.handler.StatisticsHandler.handle(StatisticsHandler.java:173)
org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:221)
org.eclipse.jetty.server.handler.gzip.GzipHandler.handle(GzipHandler.java:767)
org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)
org.eclipse.jetty.server.Server.handle(Server.java:500)
org.eclipse.jetty.server.HttpChannel.lambda$handle$1(HttpChannel.java:383)
org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:547)
org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:375)
org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:270)
org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)
org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)
org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:336)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:313)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:129)
org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:388)
org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:806)
org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:938)
java.lang.Thread.run(Thread.java:748)
 (io.confluent.ksql.cli.console.Console:325)
[2020-08-18 11:44:15,456] ERROR Exception while preparing statement: CIQ000000017_OUT_CHARGE does not exist.
Statement: SELECT * FROM CIQ000000017_out_charge;
Caused by: CIQ000000017_OUT_CHARGE does not exist.
io.confluent.ksql.engine.EngineContext.prepare(EngineContext.java:154)
io.confluent.ksql.engine.KsqlEngine.prepare(KsqlEngine.java:170)
io.confluent.ksql.rest.server.StatementParser.parseSingleStatement(StatementParser.java:42)
io.confluent.ksql.rest.server.resources.streaming.StreamedQueryResource.parseStatement(StreamedQueryResource.java:177)
io.confluent.ksql.rest.server.resources.streaming.StreamedQueryResource.streamQuery(StreamedQueryResource.java:156)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
org.glassfish.jersey.server.model.internal.ResourceMethodInvocationHandlerFactory.lambda$static$0(ResourceMethodInvocationHandlerFactory.java:52)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher$1.run(AbstractJavaResourceMethodDispatcher.java:124)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.invoke(AbstractJavaResourceMethodDispatcher.java:167)
org.glassfish.jersey.server.model.internal.JavaResourceMethodDispatcherProvider$ResponseOutInvoker.doDispatch(JavaResourceMethodDispatcherProvider.java:176)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.dispatch(AbstractJavaResourceMethodDispatcher.java:79)
org.glassfish.jersey.server.model.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:469)
org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:391)
org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:80)
org.glassfish.jersey.server.ServerRuntime$1.run(ServerRuntime.java:253)
org.glassfish.jersey.internal.Errors$1.call(Errors.java:248)
org.glassfish.jersey.internal.Errors$1.call(Errors.java:244)
org.glassfish.jersey.internal.Errors.process(Errors.java:292)
org.glassfish.jersey.internal.Errors.process(Errors.java:274)
org.glassfish.jersey.internal.Errors.process(Errors.java:244)
org.glassfish.jersey.process.internal.RequestScope.runInScope(RequestScope.java:265)
org.glassfish.jersey.server.ServerRuntime.process(ServerRuntime.java:232)
org.glassfish.jersey.server.ApplicationHandler.handle(ApplicationHandler.java:680)
org.glassfish.jersey.servlet.WebComponent.serviceImpl(WebComponent.java:394)
org.glassfish.jersey.servlet.ServletContainer.serviceImpl(ServletContainer.java:386)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:561)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:502)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:439)
org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1604)
org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:545)
org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)
org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1607)
org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)
org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1297)
org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:188)
org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:485)
org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1577)
org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:186)
org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1212)
org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146)
org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146)
org.eclipse.jetty.server.handler.StatisticsHandler.handle(StatisticsHandler.java:173)
org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:221)
org.eclipse.jetty.server.handler.gzip.GzipHandler.handle(GzipHandler.java:767)
org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)
org.eclipse.jetty.server.Server.handle(Server.java:500)
org.eclipse.jetty.server.HttpChannel.lambda$handle$1(HttpChannel.java:383)
org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:547)
org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:375)
org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:270)
org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)
org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)
org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:336)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:313)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:129)
org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:388)
org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:806)
org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:938)
java.lang.Thread.run(Thread.java:748)
 (io.confluent.ksql.cli.console.Console:325)
[2020-08-18 11:44:23,775] ERROR Exception while preparing statement: CIQ000000017_OUT_CHARGE_RAW_STREAM does not exist.
Statement: SELECT * FROM CIQ000000017_out_charge_raw_stream;
Caused by: CIQ000000017_OUT_CHARGE_RAW_STREAM does not exist.
io.confluent.ksql.engine.EngineContext.prepare(EngineContext.java:154)
io.confluent.ksql.engine.KsqlEngine.prepare(KsqlEngine.java:170)
io.confluent.ksql.rest.server.StatementParser.parseSingleStatement(StatementParser.java:42)
io.confluent.ksql.rest.server.resources.streaming.StreamedQueryResource.parseStatement(StreamedQueryResource.java:177)
io.confluent.ksql.rest.server.resources.streaming.StreamedQueryResource.streamQuery(StreamedQueryResource.java:156)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
org.glassfish.jersey.server.model.internal.ResourceMethodInvocationHandlerFactory.lambda$static$0(ResourceMethodInvocationHandlerFactory.java:52)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher$1.run(AbstractJavaResourceMethodDispatcher.java:124)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.invoke(AbstractJavaResourceMethodDispatcher.java:167)
org.glassfish.jersey.server.model.internal.JavaResourceMethodDispatcherProvider$ResponseOutInvoker.doDispatch(JavaResourceMethodDispatcherProvider.java:176)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.dispatch(AbstractJavaResourceMethodDispatcher.java:79)
org.glassfish.jersey.server.model.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:469)
org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:391)
org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:80)
org.glassfish.jersey.server.ServerRuntime$1.run(ServerRuntime.java:253)
org.glassfish.jersey.internal.Errors$1.call(Errors.java:248)
org.glassfish.jersey.internal.Errors$1.call(Errors.java:244)
org.glassfish.jersey.internal.Errors.process(Errors.java:292)
org.glassfish.jersey.internal.Errors.process(Errors.java:274)
org.glassfish.jersey.internal.Errors.process(Errors.java:244)
org.glassfish.jersey.process.internal.RequestScope.runInScope(RequestScope.java:265)
org.glassfish.jersey.server.ServerRuntime.process(ServerRuntime.java:232)
org.glassfish.jersey.server.ApplicationHandler.handle(ApplicationHandler.java:680)
org.glassfish.jersey.servlet.WebComponent.serviceImpl(WebComponent.java:394)
org.glassfish.jersey.servlet.ServletContainer.serviceImpl(ServletContainer.java:386)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:561)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:502)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:439)
org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1604)
org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:545)
org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)
org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1607)
org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)
org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1297)
org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:188)
org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:485)
org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1577)
org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:186)
org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1212)
org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146)
org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146)
org.eclipse.jetty.server.handler.StatisticsHandler.handle(StatisticsHandler.java:173)
org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:221)
org.eclipse.jetty.server.handler.gzip.GzipHandler.handle(GzipHandler.java:767)
org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)
org.eclipse.jetty.server.Server.handle(Server.java:500)
org.eclipse.jetty.server.HttpChannel.lambda$handle$1(HttpChannel.java:383)
org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:547)
org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:375)
org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:270)
org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)
org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)
org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:336)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:313)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:129)
org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:388)
org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:806)
org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:938)
java.lang.Thread.run(Thread.java:748)
 (io.confluent.ksql.cli.console.Console:325)
[2020-08-18 11:44:52,799] ERROR Exception while preparing statement: CIQ000000017_OUT_CHARGE_RAW does not exist.
Statement: SELECT * FROM CIQ000000017_out_charge_raw;
Caused by: CIQ000000017_OUT_CHARGE_RAW does not exist.
io.confluent.ksql.engine.EngineContext.prepare(EngineContext.java:154)
io.confluent.ksql.engine.KsqlEngine.prepare(KsqlEngine.java:170)
io.confluent.ksql.rest.server.StatementParser.parseSingleStatement(StatementParser.java:42)
io.confluent.ksql.rest.server.resources.streaming.StreamedQueryResource.parseStatement(StreamedQueryResource.java:177)
io.confluent.ksql.rest.server.resources.streaming.StreamedQueryResource.streamQuery(StreamedQueryResource.java:156)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
org.glassfish.jersey.server.model.internal.ResourceMethodInvocationHandlerFactory.lambda$static$0(ResourceMethodInvocationHandlerFactory.java:52)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher$1.run(AbstractJavaResourceMethodDispatcher.java:124)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.invoke(AbstractJavaResourceMethodDispatcher.java:167)
org.glassfish.jersey.server.model.internal.JavaResourceMethodDispatcherProvider$ResponseOutInvoker.doDispatch(JavaResourceMethodDispatcherProvider.java:176)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.dispatch(AbstractJavaResourceMethodDispatcher.java:79)
org.glassfish.jersey.server.model.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:469)
org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:391)
org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:80)
org.glassfish.jersey.server.ServerRuntime$1.run(ServerRuntime.java:253)
org.glassfish.jersey.internal.Errors$1.call(Errors.java:248)
org.glassfish.jersey.internal.Errors$1.call(Errors.java:244)
org.glassfish.jersey.internal.Errors.process(Errors.java:292)
org.glassfish.jersey.internal.Errors.process(Errors.java:274)
org.glassfish.jersey.internal.Errors.process(Errors.java:244)
org.glassfish.jersey.process.internal.RequestScope.runInScope(RequestScope.java:265)
org.glassfish.jersey.server.ServerRuntime.process(ServerRuntime.java:232)
org.glassfish.jersey.server.ApplicationHandler.handle(ApplicationHandler.java:680)
org.glassfish.jersey.servlet.WebComponent.serviceImpl(WebComponent.java:394)
org.glassfish.jersey.servlet.ServletContainer.serviceImpl(ServletContainer.java:386)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:561)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:502)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:439)
org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1604)
org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:545)
org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)
org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1607)
org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)
org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1297)
org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:188)
org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:485)
org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1577)
org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:186)
org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1212)
org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146)
org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146)
org.eclipse.jetty.server.handler.StatisticsHandler.handle(StatisticsHandler.java:173)
org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:221)
org.eclipse.jetty.server.handler.gzip.GzipHandler.handle(GzipHandler.java:767)
org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)
org.eclipse.jetty.server.Server.handle(Server.java:500)
org.eclipse.jetty.server.HttpChannel.lambda$handle$1(HttpChannel.java:383)
org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:547)
org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:375)
org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:270)
org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)
org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)
org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:336)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:313)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:129)
org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:388)
org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:806)
org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:938)
java.lang.Thread.run(Thread.java:748)
 (io.confluent.ksql.cli.console.Console:325)
[2020-08-18 11:48:45,157] ERROR Exception while preparing statement: CIQ000000017_out_charge_raw does not exist.
Statement: SELECT * FROM "CIQ000000017_out_charge_raw";
Caused by: CIQ000000017_out_charge_raw does not exist.
io.confluent.ksql.engine.EngineContext.prepare(EngineContext.java:154)
io.confluent.ksql.engine.KsqlEngine.prepare(KsqlEngine.java:170)
io.confluent.ksql.rest.server.StatementParser.parseSingleStatement(StatementParser.java:42)
io.confluent.ksql.rest.server.resources.streaming.StreamedQueryResource.parseStatement(StreamedQueryResource.java:177)
io.confluent.ksql.rest.server.resources.streaming.StreamedQueryResource.streamQuery(StreamedQueryResource.java:156)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
org.glassfish.jersey.server.model.internal.ResourceMethodInvocationHandlerFactory.lambda$static$0(ResourceMethodInvocationHandlerFactory.java:52)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher$1.run(AbstractJavaResourceMethodDispatcher.java:124)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.invoke(AbstractJavaResourceMethodDispatcher.java:167)
org.glassfish.jersey.server.model.internal.JavaResourceMethodDispatcherProvider$ResponseOutInvoker.doDispatch(JavaResourceMethodDispatcherProvider.java:176)
org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.dispatch(AbstractJavaResourceMethodDispatcher.java:79)
org.glassfish.jersey.server.model.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:469)
org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:391)
org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:80)
org.glassfish.jersey.server.ServerRuntime$1.run(ServerRuntime.java:253)
org.glassfish.jersey.internal.Errors$1.call(Errors.java:248)
org.glassfish.jersey.internal.Errors$1.call(Errors.java:244)
org.glassfish.jersey.internal.Errors.process(Errors.java:292)
org.glassfish.jersey.internal.Errors.process(Errors.java:274)
org.glassfish.jersey.internal.Errors.process(Errors.java:244)
org.glassfish.jersey.process.internal.RequestScope.runInScope(RequestScope.java:265)
org.glassfish.jersey.server.ServerRuntime.process(ServerRuntime.java:232)
org.glassfish.jersey.server.ApplicationHandler.handle(ApplicationHandler.java:680)
org.glassfish.jersey.servlet.WebComponent.serviceImpl(WebComponent.java:394)
org.glassfish.jersey.servlet.ServletContainer.serviceImpl(ServletContainer.java:386)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:561)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:502)
org.glassfish.jersey.servlet.ServletContainer.doFilter(ServletContainer.java:439)
org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1604)
org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:545)
org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)
org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1607)
org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)
org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1297)
org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:188)
org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:485)
org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1577)
org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:186)
org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1212)
org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146)
org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146)
org.eclipse.jetty.server.handler.StatisticsHandler.handle(StatisticsHandler.java:173)
org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:221)
org.eclipse.jetty.server.handler.gzip.GzipHandler.handle(GzipHandler.java:767)
org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)
org.eclipse.jetty.server.Server.handle(Server.java:500)
org.eclipse.jetty.server.HttpChannel.lambda$handle$1(HttpChannel.java:383)
org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:547)
org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:375)
org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:270)
org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)
org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)
org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:336)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:313)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171)
org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:129)
org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:388)
org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:806)
org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:938)
java.lang.Thread.run(Thread.java:748)
 (io.confluent.ksql.cli.console.Console:325)
[2020-08-18 11:49:01,741] ERROR 'CIQ000000017_out_charge_raw_stream' is not materialized. Refer to https://cnfl.io/queries for info on query types. If you intended to issue a push query, resubmit with the EMIT CHANGES clause
 KSQL currently only supports pull queries on materialized aggregate tables. i.e. those created by a 'CREATE TABLE AS SELECT <fields>, <aggregate_functions> FROM <sources> GROUP BY <key>' style statement.
Query syntax in KSQL has changed. There are now two broad categories of queries:
- Pull queries: query the current state of the system, return a result, and terminate. 
- Push queries: query the state of the system in motion and continue to output results until they meet a LIMIT condition or are terminated by the user.

'EMIT CHANGES' is used to to indicate a query is a push query. To convert a pull query into a push query, which was the default behavior in older versions of KSQL, add `EMIT CHANGES` to the end of the statement before any LIMIT clause.

For example, the following are pull queries:
	'SELECT * FROM X WHERE ROWKEY=Y;' (non-windowed table)
	'SELECT * FROM X WHERE ROWKEY=Y AND WINDOWSTART>=Z;' (windowed table)

The following is a push query:
	'SELECT * FROM X EMIT CHANGES;'

Note: Persistent queries, e.g. `CREATE TABLE AS ...`, have an implicit `EMIT CHANGES`, but we recommend adding `EMIT CHANGES` to these statements for clarify.
 (io.confluent.ksql.cli.console.Console:325)
[2020-08-18 12:11:59,790] ERROR  (io.confluent.ksql.cli.Cli:177)
io.confluent.ksql.parser.exception.ParseFailedException: line 1:15: mismatched input ''CIQ000000017_out_charge_compacted_table'' expecting {'EMIT', 'CHANGES', 'INTEGER', 'DATE', 'TIME', 'TIMESTAMP', 'INTERVAL', 'YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'ZONE', 'PARTITION', 'STRUCT', 'EXPLAIN', 'ANALYZE', 'TYPE', 'TYPES', 'SHOW', 'TABLES', 'COLUMNS', 'COLUMN', 'PARTITIONS', 'FUNCTIONS', 'FUNCTION', 'ARRAY', 'MAP', 'SET', 'RESET', 'SESSION', 'KEY', 'SINK', 'SOURCE', 'IF', IDENTIFIER, DIGIT_IDENTIFIER, QUOTED_IDENTIFIER, BACKQUOTED_IDENTIFIER}
Statement: SELECT * FROM 'CIQ000000017_out_charge_compacted_table';
	at io.confluent.ksql.parser.DefaultKsqlParser.parse(DefaultKsqlParser.java:64)
	at io.confluent.ksql.cli.Cli.handleStatements(Cli.java:265)
	at io.confluent.ksql.cli.Cli.handleLine(Cli.java:232)
	at io.confluent.ksql.cli.Cli.runInteractively(Cli.java:171)
	at io.confluent.ksql.Ksql.run(Ksql.java:115)
	at io.confluent.ksql.Ksql.main(Ksql.java:74)
Caused by: io.confluent.ksql.parser.ParsingException: line 1:15: mismatched input ''CIQ000000017_out_charge_compacted_table'' expecting {'EMIT', 'CHANGES', 'INTEGER', 'DATE', 'TIME', 'TIMESTAMP', 'INTERVAL', 'YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'ZONE', 'PARTITION', 'STRUCT', 'EXPLAIN', 'ANALYZE', 'TYPE', 'TYPES', 'SHOW', 'TABLES', 'COLUMNS', 'COLUMN', 'PARTITIONS', 'FUNCTIONS', 'FUNCTION', 'ARRAY', 'MAP', 'SET', 'RESET', 'SESSION', 'KEY', 'SINK', 'SOURCE', 'IF', IDENTIFIER, DIGIT_IDENTIFIER, QUOTED_IDENTIFIER, BACKQUOTED_IDENTIFIER}
	at io.confluent.ksql.parser.DefaultKsqlParser$1.syntaxError(DefaultKsqlParser.java:50)
	at org.antlr.v4.runtime.ProxyErrorListener.syntaxError(ProxyErrorListener.java:41)
	at org.antlr.v4.runtime.Parser.notifyErrorListeners(Parser.java:544)
	at org.antlr.v4.runtime.DefaultErrorStrategy.reportInputMismatch(DefaultErrorStrategy.java:299)
	at org.antlr.v4.runtime.DefaultErrorStrategy.reportError(DefaultErrorStrategy.java:124)
	at io.confluent.ksql.parser.SqlBaseParser.relation(SqlBaseParser.java:3365)
	at io.confluent.ksql.parser.SqlBaseParser.query(SqlBaseParser.java:1881)
	at io.confluent.ksql.parser.SqlBaseParser.statement(SqlBaseParser.java:1023)
	at io.confluent.ksql.parser.SqlBaseParser.singleStatement(SqlBaseParser.java:264)
	at io.confluent.ksql.parser.SqlBaseParser.statements(SqlBaseParser.java:212)
	at io.confluent.ksql.parser.DefaultKsqlParser.getParseTree(DefaultKsqlParser.java:108)
	at io.confluent.ksql.parser.DefaultKsqlParser.parse(DefaultKsqlParser.java:57)
	... 5 more
Caused by: org.antlr.v4.runtime.InputMismatchException
	at org.antlr.v4.runtime.DefaultErrorStrategy.sync(DefaultErrorStrategy.java:242)
	at io.confluent.ksql.parser.SqlBaseParser.relation(SqlBaseParser.java:3325)
	... 11 more
[2020-08-18 12:12:18,750] ERROR 'CIQ000000017_out_charge_compacted_table' is not materialized. Refer to https://cnfl.io/queries for info on query types. If you intended to issue a push query, resubmit with the EMIT CHANGES clause
 KSQL currently only supports pull queries on materialized aggregate tables. i.e. those created by a 'CREATE TABLE AS SELECT <fields>, <aggregate_functions> FROM <sources> GROUP BY <key>' style statement.
Query syntax in KSQL has changed. There are now two broad categories of queries:
- Pull queries: query the current state of the system, return a result, and terminate. 
- Push queries: query the state of the system in motion and continue to output results until they meet a LIMIT condition or are terminated by the user.

'EMIT CHANGES' is used to to indicate a query is a push query. To convert a pull query into a push query, which was the default behavior in older versions of KSQL, add `EMIT CHANGES` to the end of the statement before any LIMIT clause.

For example, the following are pull queries:
	'SELECT * FROM X WHERE ROWKEY=Y;' (non-windowed table)
	'SELECT * FROM X WHERE ROWKEY=Y AND WINDOWSTART>=Z;' (windowed table)

The following is a push query:
	'SELECT * FROM X EMIT CHANGES;'

Note: Persistent queries, e.g. `CREATE TABLE AS ...`, have an implicit `EMIT CHANGES`, but we recommend adding `EMIT CHANGES` to these statements for clarify.
 (io.confluent.ksql.cli.console.Console:325)
